{
  "address": "0x84282bF86f09082f3d34a70ABf47D2d3Cc7a9ffb",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_l2OutputOracle",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "layout",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "length",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "storageHash",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "stateTrieWitness",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "l2OutputIndex",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "version",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "stateRoot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "messagePasserStorageRoot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "latestBlockhash",
                  "type": "bytes32"
                }
              ],
              "internalType": "struct Types.OutputRootProof",
              "name": "outputRootProof",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "key",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes",
                  "name": "storageTrieWitness",
                  "type": "bytes"
                }
              ],
              "internalType": "struct IBedrockProofVerifier.StorageProof[]",
              "name": "storageProofs",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct IBedrockProofVerifier.BedrockStateProof",
          "name": "proof",
          "type": "tuple"
        }
      ],
      "name": "getProofValue",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "l2OutputOracle",
      "outputs": [
        {
          "internalType": "contract IL2OutputOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x9db1d716dbbff72c8334c24cd0d01d7ad08e42dff86ac9958219306f354157c6",
  "receipt": {
    "to": null,
    "from": "0xFC04D70bea992Da2C67995BbddC3500767394513",
    "contractAddress": "0x84282bF86f09082f3d34a70ABf47D2d3Cc7a9ffb",
    "transactionIndex": 16,
    "gasUsed": "2677890",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x58361a95818cb070b8da4486f2a47964c615a6ac9ccc32d07bc8d6c4fecd9cd9",
    "transactionHash": "0x9db1d716dbbff72c8334c24cd0d01d7ad08e42dff86ac9958219306f354157c6",
    "logs": [],
    "blockNumber": 9556290,
    "cumulativeGasUsed": "4838014",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
  ],
  "numDeployments": 1,
  "solcInputHash": "0445fa0d01b10caeaef9d49402886916",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l2OutputOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"layout\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"storageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"stateTrieWitness\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"l2OutputIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"version\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"messagePasserStorageRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"latestBlockhash\",\"type\":\"bytes32\"}],\"internalType\":\"struct Types.OutputRootProof\",\"name\":\"outputRootProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"storageTrieWitness\",\"type\":\"bytes\"}],\"internalType\":\"struct IBedrockProofVerifier.StorageProof[]\",\"name\":\"storageProofs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IBedrockProofVerifier.BedrockStateProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"getProofValue\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2OutputOracle\",\"outputs\":[{\"internalType\":\"contract IL2OutputOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getProofValue((uint8,address,uint256,bytes32,bytes,uint256,(bytes32,bytes32,bytes32,bytes32),(bytes32,bytes)[]))\":{\"details\":\"This function validates the provided BedrockStateProof and returns the value of the slot or slots included in the proof.\",\"params\":{\"proof\":\"The BedrockStateProof struct containing the necessary proof data\"},\"returns\":{\"_0\":\"result The value of the slot or slots included in the proof\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getProofValue((uint8,address,uint256,bytes32,bytes,uint256,(bytes32,bytes32,bytes32,bytes32),(bytes32,bytes)[]))\":{\"notice\":\"Get the proof value for the provided BedrockStateProof\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/verifier/optimism-bedrock/BedrockProofVerifier.sol\":\"BedrockProofVerifier\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"u\",\"stackAllocation\":true}},\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@eth-optimism/contracts-bedrock/contracts/libraries/Encoding.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\nimport { Hashing } from \\\"./Hashing.sol\\\";\\nimport { RLPWriter } from \\\"./rlp/RLPWriter.sol\\\";\\n\\n/**\\n * @title Encoding\\n * @notice Encoding handles Optimism's various different encoding schemes.\\n */\\nlibrary Encoding {\\n    /**\\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\\n     *         to the L2 system. Useful for searching for a deposit in the L2 system. The\\n     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.\\n     *\\n     * @param _tx User deposit transaction to encode.\\n     *\\n     * @return RLP encoded L2 deposit transaction.\\n     */\\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\\n        bytes[] memory raw = new bytes[](8);\\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\\n        raw[1] = RLPWriter.writeAddress(_tx.from);\\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\\\"\\\") : RLPWriter.writeAddress(_tx.to);\\n        raw[3] = RLPWriter.writeUint(_tx.mint);\\n        raw[4] = RLPWriter.writeUint(_tx.value);\\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\\n        raw[6] = RLPWriter.writeBool(false);\\n        raw[7] = RLPWriter.writeBytes(_tx.data);\\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\\n    }\\n\\n    /**\\n     * @notice Encodes the cross domain message based on the version that is encoded into the\\n     *         message nonce.\\n     *\\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _value    ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Encoded cross domain message.\\n     */\\n    function encodeCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes memory) {\\n        (, uint16 version) = decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Encoding: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Encodes a cross domain message based on the V0 (legacy) encoding.\\n     *\\n     * @param _target Address of the target of the message.\\n     * @param _sender Address of the sender of the message.\\n     * @param _data   Data to send with the message.\\n     * @param _nonce  Message nonce.\\n     *\\n     * @return Encoded cross domain message.\\n     */\\n    function encodeCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"relayMessage(address,address,bytes,uint256)\\\",\\n                _target,\\n                _sender,\\n                _data,\\n                _nonce\\n            );\\n    }\\n\\n    /**\\n     * @notice Encodes a cross domain message based on the V1 (current) encoding.\\n     *\\n     * @param _nonce    Message nonce.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _value    ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Encoded cross domain message.\\n     */\\n    function encodeCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"relayMessage(uint256,address,address,uint256,uint256,bytes)\\\",\\n                _nonce,\\n                _sender,\\n                _target,\\n                _value,\\n                _gasLimit,\\n                _data\\n            );\\n    }\\n\\n    /**\\n     * @notice Adds a version number into the first two bytes of a message nonce.\\n     *\\n     * @param _nonce   Message nonce to encode into.\\n     * @param _version Version number to encode into the message nonce.\\n     *\\n     * @return Message nonce with version encoded into the first two bytes.\\n     */\\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\\n        uint256 nonce;\\n        assembly {\\n            nonce := or(shl(240, _version), _nonce)\\n        }\\n        return nonce;\\n    }\\n\\n    /**\\n     * @notice Pulls the version out of a version-encoded nonce.\\n     *\\n     * @param _nonce Message nonce with version encoded into the first two bytes.\\n     *\\n     * @return Nonce without encoded version.\\n     * @return Version of the message.\\n     */\\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\\n        uint240 nonce;\\n        uint16 version;\\n        assembly {\\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            version := shr(240, _nonce)\\n        }\\n        return (nonce, version);\\n    }\\n}\\n\",\"keccak256\":\"0x170cd0821cec37976a6391da20f1dcdcb1ea9ffada96ccd3c57ff2e357589418\",\"license\":\"MIT\"},\"@eth-optimism/contracts-bedrock/contracts/libraries/Hashing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\nimport { Encoding } from \\\"./Encoding.sol\\\";\\n\\n/**\\n * @title Hashing\\n * @notice Hashing handles Optimism's various different hashing schemes.\\n */\\nlibrary Hashing {\\n    /**\\n     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\\n     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\\n     *         system.\\n     *\\n     * @param _tx User deposit transaction to hash.\\n     *\\n     * @return Hash of the RLP encoded L2 deposit transaction.\\n     */\\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\\n    }\\n\\n    /**\\n     * @notice Computes the deposit transaction's \\\"source hash\\\", a value that guarantees the hash\\n     *         of the L2 transaction that corresponds to a deposit is unique and is\\n     *         deterministically generated from L1 transaction data.\\n     *\\n     * @param _l1BlockHash Hash of the L1 block where the deposit was included.\\n     * @param _logIndex    The index of the log that created the deposit transaction.\\n     *\\n     * @return Hash of the deposit transaction's \\\"source hash\\\".\\n     */\\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\\n        return keccak256(abi.encode(bytes32(0), depositId));\\n    }\\n\\n    /**\\n     * @notice Hashes the cross domain message based on the version that is encoded into the\\n     *         message nonce.\\n     *\\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _value    ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Hashed cross domain message.\\n     */\\n    function hashCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes32) {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Hashing: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Hashes a cross domain message based on the V0 (legacy) encoding.\\n     *\\n     * @param _target Address of the target of the message.\\n     * @param _sender Address of the sender of the message.\\n     * @param _data   Data to send with the message.\\n     * @param _nonce  Message nonce.\\n     *\\n     * @return Hashed cross domain message.\\n     */\\n    function hashCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    ) internal pure returns (bytes32) {\\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\\n    }\\n\\n    /**\\n     * @notice Hashes a cross domain message based on the V1 (current) encoding.\\n     *\\n     * @param _nonce    Message nonce.\\n     * @param _sender   Address of the sender of the message.\\n     * @param _target   Address of the target of the message.\\n     * @param _value    ETH value to send to the target.\\n     * @param _gasLimit Gas limit to use for the message.\\n     * @param _data     Data to send with the message.\\n     *\\n     * @return Hashed cross domain message.\\n     */\\n    function hashCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                Encoding.encodeCrossDomainMessageV1(\\n                    _nonce,\\n                    _sender,\\n                    _target,\\n                    _value,\\n                    _gasLimit,\\n                    _data\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\\n     *\\n     * @param _tx Withdrawal transaction to hash.\\n     *\\n     * @return Hashed withdrawal transaction.\\n     */\\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data)\\n            );\\n    }\\n\\n    /**\\n     * @notice Hashes the various elements of an output root proof into an output root hash which\\n     *         can be used to check if the proof is valid.\\n     *\\n     * @param _outputRootProof Output root proof which should hash to an output root.\\n     *\\n     * @return Hashed output root proof.\\n     */\\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _outputRootProof.version,\\n                    _outputRootProof.stateRoot,\\n                    _outputRootProof.messagePasserStorageRoot,\\n                    _outputRootProof.latestBlockhash\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x5d4988987899306d2785b3de068194a39f8e829a7864762a07a0016db5189f5e\",\"license\":\"MIT\"},\"@eth-optimism/contracts-bedrock/contracts/libraries/Types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Types\\n * @notice Contains various types used throughout the Optimism contract system.\\n */\\nlibrary Types {\\n    /**\\n     * @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\\n     *         timestamp that the output root is posted. This timestamp is used to verify that the\\n     *         finalization period has passed since the output root was submitted.\\n     *\\n     * @custom:field outputRoot    Hash of the L2 output.\\n     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\\n     * @custom:field l2BlockNumber L2 block number that the output corresponds to.\\n     */\\n    struct OutputProposal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2BlockNumber;\\n    }\\n\\n    /**\\n     * @notice Struct representing the elements that are hashed together to generate an output root\\n     *         which itself represents a snapshot of the L2 state.\\n     *\\n     * @custom:field version                  Version of the output root.\\n     * @custom:field stateRoot                Root of the state trie at the block of this output.\\n     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.\\n     * @custom:field latestBlockhash          Hash of the block this output was generated from.\\n     */\\n    struct OutputRootProof {\\n        bytes32 version;\\n        bytes32 stateRoot;\\n        bytes32 messagePasserStorageRoot;\\n        bytes32 latestBlockhash;\\n    }\\n\\n    /**\\n     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\\n     *         user (as opposed to a system deposit transaction generated by the system).\\n     *\\n     * @custom:field from        Address of the sender of the transaction.\\n     * @custom:field to          Address of the recipient of the transaction.\\n     * @custom:field isCreation  True if the transaction is a contract creation.\\n     * @custom:field value       Value to send to the recipient.\\n     * @custom:field mint        Amount of ETH to mint.\\n     * @custom:field gasLimit    Gas limit of the transaction.\\n     * @custom:field data        Data of the transaction.\\n     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.\\n     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.\\n     */\\n    struct UserDepositTransaction {\\n        address from;\\n        address to;\\n        bool isCreation;\\n        uint256 value;\\n        uint256 mint;\\n        uint64 gasLimit;\\n        bytes data;\\n        bytes32 l1BlockHash;\\n        uint256 logIndex;\\n    }\\n\\n    /**\\n     * @notice Struct representing a withdrawal transaction.\\n     *\\n     * @custom:field nonce    Nonce of the withdrawal transaction\\n     * @custom:field sender   Address of the sender of the transaction.\\n     * @custom:field target   Address of the recipient of the transaction.\\n     * @custom:field value    Value to send to the recipient.\\n     * @custom:field gasLimit Gas limit of the transaction.\\n     * @custom:field data     Data of the transaction.\\n     */\\n    struct WithdrawalTransaction {\\n        uint256 nonce;\\n        address sender;\\n        address target;\\n        uint256 value;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n}\\n\",\"keccak256\":\"0x4fe8ec920798661a828430bd30dc2715eeb40534ec01c0a7bf41cb4ab422e134\",\"license\":\"MIT\"},\"@eth-optimism/contracts-bedrock/contracts/libraries/rlp/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/**\\n * @custom:attribution https://github.com/hamdiallam/Solidity-RLP\\n * @title RLPReader\\n * @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\\n *         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\\n *         various tweaks to improve readability.\\n */\\nlibrary RLPReader {\\n    /**\\n     * Custom pointer type to avoid confusion between pointers and uint256s.\\n     */\\n    type MemoryPointer is uint256;\\n\\n    /**\\n     * @notice RLP item types.\\n     *\\n     * @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\\n     * @custom:value LIST_ITEM Represents an RLP list item.\\n     */\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /**\\n     * @notice Struct representing an RLP item.\\n     *\\n     * @custom:field length Length of the RLP item.\\n     * @custom:field ptr    Pointer to the RLP item in memory.\\n     */\\n    struct RLPItem {\\n        uint256 length;\\n        MemoryPointer ptr;\\n    }\\n\\n    /**\\n     * @notice Max list length that this library will accept.\\n     */\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /**\\n     * @notice Converts bytes to a reference to memory position and length.\\n     *\\n     * @param _in Input bytes to convert.\\n     *\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n        // Empty arrays are not RLP items.\\n        require(\\n            _in.length > 0,\\n            \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\"\\n        );\\n\\n        MemoryPointer ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /**\\n     * @notice Reads an RLP list value into a list of RLP items.\\n     *\\n     * @param _in RLP list value.\\n     *\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"RLPReader: decoded item type for list is not a list item\\\"\\n        );\\n\\n        require(\\n            listOffset + listLength == _in.length,\\n            \\\"RLPReader: list item has an invalid data remainder\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n                RLPItem({\\n                    length: _in.length - offset,\\n                    ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n                })\\n            );\\n\\n            // We don't need to check itemCount < out.length explicitly because Solidity already\\n            // handles this check on our behalf, we'd just be wasting gas.\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * @notice Reads an RLP list value into a list of RLP items.\\n     *\\n     * @param _in RLP list value.\\n     *\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n        return readList(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * @notice Reads an RLP bytes value into bytes.\\n     *\\n     * @param _in RLP bytes value.\\n     *\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"RLPReader: decoded item type for bytes is not a data item\\\"\\n        );\\n\\n        require(\\n            _in.length == itemOffset + itemLength,\\n            \\\"RLPReader: bytes value contains an invalid remainder\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * @notice Reads an RLP bytes value into bytes.\\n     *\\n     * @param _in RLP bytes value.\\n     *\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        return readBytes(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * @notice Reads the raw bytes of an RLP item.\\n     *\\n     * @param _in RLP item to read.\\n     *\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n\\n    /**\\n     * @notice Decodes the length of an RLP item.\\n     *\\n     * @param _in RLP item to decode.\\n     *\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        // Short-circuit if there's nothing to decode, note that we perform this check when\\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\\n        // that function and create an RLP item directly. So we need to check this anyway.\\n        require(\\n            _in.length > 0,\\n            \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\"\\n        );\\n\\n        MemoryPointer ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen,\\n                \\\"RLPReader: length of content must be greater than string length (short string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                strLen != 1 || firstByteOfContent >= 0x80,\\n                \\\"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"RLPReader: length of content must be > than length of string length (long string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00,\\n                \\\"RLPReader: length of content must not have any leading zeros (long string)\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(\\n                strLen > 55,\\n                \\\"RLPReader: length of content must be greater than 55 bytes (long string)\\\"\\n            );\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"RLPReader: length of content must be greater than total length (long string)\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"RLPReader: length of content must be greater than list length (short list)\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"RLPReader: length of content must be > than length of list length (long list)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00,\\n                \\\"RLPReader: length of content must not have any leading zeros (long list)\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(\\n                listLen > 55,\\n                \\\"RLPReader: length of content must be greater than 55 bytes (long list)\\\"\\n            );\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"RLPReader: length of content must be greater than total length (long list)\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * @notice Copies the bytes from a memory location.\\n     *\\n     * @param _src    Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     *\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        MemoryPointer _src,\\n        uint256 _offset,\\n        uint256 _length\\n    ) private pure returns (bytes memory) {\\n        bytes memory out = new bytes(_length);\\n        if (_length == 0) {\\n            return out;\\n        }\\n\\n        // Mostly based on Solidity's copy_memory_to_memory:\\n        // solhint-disable max-line-length\\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\\n        assembly {\\n            let dest := add(out, 32)\\n            let i := 0\\n            for {\\n\\n            } lt(i, _length) {\\n                i := add(i, 32)\\n            } {\\n                mstore(add(dest, i), mload(add(src, i)))\\n            }\\n\\n            if gt(i, _length) {\\n                mstore(add(dest, _length), 0)\\n            }\\n        }\\n\\n        return out;\\n    }\\n}\\n\",\"keccak256\":\"0x50763c897f0fe84cb067985ec4d7c5721ce9004a69cf0327f96f8982ee8ca412\",\"license\":\"MIT\"},\"@eth-optimism/contracts-bedrock/contracts/libraries/rlp/RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n * @title RLPWriter\\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n *         modifications to improve legibility.\\n */\\nlibrary RLPWriter {\\n    /**\\n     * @notice RLP encodes a byte string.\\n     *\\n     * @param _in The byte string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\\n     *\\n     * @param _in The list of RLP encoded byte strings.\\n     *\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * @notice RLP encodes a string.\\n     *\\n     * @param _in The string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes an address.\\n     *\\n     * @param _in The address to encode.\\n     *\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a uint.\\n     *\\n     * @param _in The uint256 to encode.\\n     *\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a bool.\\n     *\\n     * @param _in The bool to encode.\\n     *\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n     *\\n     * @param _len    The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode integer in big endian binary form with no leading zeroes.\\n     *\\n     * @param _x The integer to encode.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n     * @notice Copies a piece of memory to another location.\\n     *\\n     * @param _dest Destination location.\\n     * @param _src  Source location.\\n     * @param _len  Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    ) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n     * @notice Flattens a list of byte strings into one byte string.\\n     *\\n     * @param _list List of byte strings to flatten.\\n     *\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0x5aa9d21c5b41c9786f23153f819d561ae809a1d55c7b0d423dfeafdfbacedc78\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.LIST_ITEM, \\\"Invalid RLP list value.\\\");\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(itemCount < MAX_LIST_LENGTH, \\\"Provided RLP list exceeds max list length.\\\");\\n\\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\\n            );\\n\\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n        return readList(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes value.\\\");\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        return readBytes(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(bytes memory _in) internal pure returns (string memory) {\\n        return readString(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\\n        require(_in.length <= 33, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\\n        return readBytes32(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\\n        return readUint256(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\\n        require(_in.length == 1, \\\"Invalid RLP boolean value.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(out == 0 || out == 1, \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\");\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(bytes memory _in) internal pure returns (bool) {\\n        return readBool(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(_in.length == 21, \\\"Invalid RLP address value.\\\");\\n\\n        return address(uint160(readUint256(_in)));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(bytes memory _in) internal pure returns (address) {\\n        return readAddress(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        return _copy(_in);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(_in.length > 0, \\\"RLP item cannot be null.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(_in.length > strLen, \\\"Invalid RLP short string.\\\");\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(_in.length > lenOfStrLen, \\\"Invalid RLP long string length.\\\");\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\\n            }\\n\\n            require(_in.length > lenOfStrLen + strLen, \\\"Invalid RLP long string.\\\");\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(_in.length > listLen, \\\"Invalid RLP short list.\\\");\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(_in.length > lenOfListLen, \\\"Invalid RLP long list length.\\\");\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\\n            }\\n\\n            require(_in.length > lenOfListLen + listLen, \\\"Invalid RLP long list.\\\");\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    ) private pure returns (bytes memory) {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - (_length % 32)) - 1;\\n        }\\n\\n        assembly {\\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0xd794d1b32c6e31d40e2526b5e519de1b4e8d14d6933889f9b916e69c5d1848c6\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    ) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0x215b90672ce126effc3f2df61ca0cdf52d2b1cc9be602877e637829b0bf229fd\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/trie/Lib_MerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\n\\n/**\\n * @title Lib_MerkleTrie\\n */\\nlibrary Lib_MerkleTrie {\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    enum NodeType {\\n        BranchNode,\\n        ExtensionNode,\\n        LeafNode\\n    }\\n\\n    struct TrieNode {\\n        bytes encoded;\\n        Lib_RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /**********************\\n     * Contract Constants *\\n     **********************/\\n\\n    // TREE_RADIX determines the number of elements per branch node.\\n    uint256 constant TREE_RADIX = 16;\\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    // Prefixes are prepended to the `path` within a leaf or extension node and\\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\\n    // determined by the number of nibbles within the unprefixed `path`. If the\\n    // number of nibbles if even, we need to insert an extra padding nibble so\\n    // the resulting prefixed `path` has an even number of nibbles.\\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\\n    uint8 constant PREFIX_LEAF_EVEN = 2;\\n    uint8 constant PREFIX_LEAF_ODD = 3;\\n\\n    // Just a utility constant. RLP represents `NULL` as 0x80.\\n    bytes1 constant RLP_NULL = bytes1(0x80);\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _verified) {\\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\\n\\n        return (exists && Lib_BytesUtils.equal(_value, value));\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _exists, bytes memory _value) {\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\\n            proof,\\n            _key,\\n            _root\\n        );\\n\\n        bool exists = keyRemainder.length == 0;\\n\\n        require(exists || isFinalNode, \\\"Provided proof is invalid.\\\");\\n\\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\\\"\\\");\\n\\n        return (exists, value);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * @notice Walks through a proof using a provided key.\\n     * @param _proof Inclusion proof to walk through.\\n     * @param _key Key to use for the walk.\\n     * @param _root Known root of the trie.\\n     * @return _pathLength Length of the final path\\n     * @return _keyRemainder Portion of the key remaining after the walk.\\n     * @return _isFinalNode Whether or not we've hit a dead end.\\n     */\\n    function _walkNodePath(\\n        TrieNode[] memory _proof,\\n        bytes memory _key,\\n        bytes32 _root\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256 _pathLength,\\n            bytes memory _keyRemainder,\\n            bool _isFinalNode\\n        )\\n    {\\n        uint256 pathLength = 0;\\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n        bytes32 currentNodeID = _root;\\n        uint256 currentKeyIndex = 0;\\n        uint256 currentKeyIncrement = 0;\\n        TrieNode memory currentNode;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < _proof.length; i++) {\\n            currentNode = _proof[i];\\n            currentKeyIndex += currentKeyIncrement;\\n\\n            // Keep track of the proof elements we actually need.\\n            // It's expensive to resize arrays, so this simply reduces gas costs.\\n            pathLength += 1;\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(keccak256(currentNode.encoded) == currentNodeID, \\\"Invalid root hash\\\");\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    keccak256(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 31 bytes aren't hashed.\\n                require(\\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid internal node hash\\\"\\n                );\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // We've hit the end of the key\\n                    // meaning the value should be within this branch node.\\n                    break;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIncrement = 1;\\n                    continue;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    if (\\n                        pathRemainder.length == sharedNibbleLength &&\\n                        keyRemainder.length == sharedNibbleLength\\n                    ) {\\n                        // The key within this leaf matches our key exactly.\\n                        // Increment the key index to reflect that we have no remainder.\\n                        currentKeyIndex += sharedNibbleLength;\\n                    }\\n\\n                    // We've hit a leaf node, so our next node should be NULL.\\n                    currentNodeID = bytes32(RLP_NULL);\\n                    break;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    if (sharedNibbleLength != pathRemainder.length) {\\n                        // Our extension node is not identical to the remainder.\\n                        // We've hit the end of this path\\n                        // updates will need to modify this extension.\\n                        currentNodeID = bytes32(RLP_NULL);\\n                        break;\\n                    } else {\\n                        // Our extension shares some nibbles.\\n                        // Carry on to the next node.\\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                        currentKeyIncrement = sharedNibbleLength;\\n                        continue;\\n                    }\\n                } else {\\n                    revert(\\\"Received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"Received an unparseable node.\\\");\\n            }\\n        }\\n\\n        // If our node ID is NULL, then we're at a dead end.\\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\\n    }\\n\\n    /**\\n     * @notice Parses an RLP-encoded proof into something more useful.\\n     * @param _proof RLP-encoded proof to parse.\\n     * @return _parsed Proof parsed into easily accessible structs.\\n     */\\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\\n\\n        for (uint256 i = 0; i < nodes.length; i++) {\\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\\n            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\\n        }\\n\\n        return proof;\\n    }\\n\\n    /**\\n     * @notice Picks out the ID for a node. Node ID is referred to as the\\n     * \\\"hash\\\" within the specification, but nodes < 32 bytes are not actually\\n     * hashed.\\n     * @param _node Node to pull an ID for.\\n     * @return _nodeID ID for the node, depending on the size of its contents.\\n     */\\n    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\\n        bytes memory nodeID;\\n\\n        if (_node.length < 32) {\\n            // Nodes smaller than 32 bytes are RLP encoded.\\n            nodeID = Lib_RLPReader.readRawBytes(_node);\\n        } else {\\n            // Nodes 32 bytes or larger are hashed.\\n            nodeID = Lib_RLPReader.readBytes(_node);\\n        }\\n\\n        return Lib_BytesUtils.toBytes32(nodeID);\\n    }\\n\\n    /**\\n     * @notice Gets the path for a leaf or extension node.\\n     * @param _node Node to get a path for.\\n     * @return _path Node path, converted to an array of nibbles.\\n     */\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /**\\n     * @notice Gets the path for a node.\\n     * @param _node Node to get a value for.\\n     * @return _value Node value, as hex bytes.\\n     */\\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\\n    }\\n\\n    /**\\n     * @notice Utility; determines the number of nibbles shared between two\\n     * nibble arrays.\\n     * @param _a First nibble array.\\n     * @param _b Second nibble array.\\n     * @return _shared Number of shared nibbles.\\n     */\\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\\n        private\\n        pure\\n        returns (uint256 _shared)\\n    {\\n        uint256 i = 0;\\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\\n            i++;\\n        }\\n        return i;\\n    }\\n}\\n\",\"keccak256\":\"0x081304d7627b242e0a5724785a9cc4128b3104460f234ffe404d7bc87c1ad162\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/trie/Lib_SecureMerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_MerkleTrie } from \\\"./Lib_MerkleTrie.sol\\\";\\n\\n/**\\n * @title Lib_SecureMerkleTrie\\n */\\nlibrary Lib_SecureMerkleTrie {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _verified) {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _exists, bytes memory _value) {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Computes the secure counterpart to a key.\\n     * @param _key Key to get a secure key from.\\n     * @return _secureKey Secure version of the key.\\n     */\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\\n        return abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\",\"keccak256\":\"0x38e47070ba79b1049b6d623db3377322d98c2217e8fa786bd48116fc7e3bfd9e\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0xc39ee13f97e4ccfbc72a5aac571deb3c1aff882fca2dd18be794d43ac5de0a30\",\"license\":\"MIT\"},\"contracts/verifier/optimism-bedrock/BedrockProofVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IBedrockProofVerifier, IL2OutputOracle} from \\\"./IBedrockProofVerifier.sol\\\";\\n\\nimport {RLPReader} from \\\"@eth-optimism/contracts-bedrock/contracts/libraries/rlp/RLPReader.sol\\\";\\nimport {Hashing} from \\\"@eth-optimism/contracts-bedrock/contracts/libraries/Hashing.sol\\\";\\n\\nimport {Lib_SecureMerkleTrie} from \\\"@eth-optimism/contracts/libraries/trie/Lib_SecureMerkleTrie.sol\\\";\\n\\nimport {BytesLib} from \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\n\\ncontract BedrockProofVerifier is IBedrockProofVerifier {\\n    IL2OutputOracle public immutable l2OutputOracle;\\n\\n    constructor(address _l2OutputOracle) {\\n        l2OutputOracle = IL2OutputOracle(_l2OutputOracle);\\n    }\\n\\n    /**\\n     * @notice Get the proof value for the provided BedrockStateProof\\n     * @dev This function validates the provided BedrockStateProof and returns the value of the slot or slots included in the proof.\\n     * @param proof The BedrockStateProof struct containing the necessary proof data\\n     * @return result The value of the slot or slots included in the proof\\n     */\\n    function getProofValue(BedrockStateProof memory proof) public view override returns (bytes memory) {\\n        /*\\n         * Validate the provided output root is valid\\n         * See https://github.com/ethereum-optimism/optimism/blob/4611198bf8bfd16563cc6bdf49bb35eed2e46801/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L261\\n         */\\n        require(\\n            l2OutputOracle.getL2Output(proof.l2OutputIndex).outputRoot == Hashing.hashOutputRootProof(proof.outputRootProof),\\n            \\\"Invalid output root\\\"\\n        );\\n\\n        bytes memory result = getMultipleStorageProofs(proof);\\n\\n        /*\\n         * If the storage layout is fixed, the result doesn't need to be trimmed\\n         */\\n        if (proof.layout == 0) {\\n            return result;\\n        }\\n        return trimResult(result, proof.length);\\n    }\\n\\n    /**\\n     * @notice Get the storage root for the provided BedrockStateProof\\n     * @dev This private function retrieves the storage root based on the provided BedrockStateProof.\\n     * @param proof The BedrockStateProof struct containing the necessary proof data\\n     * @return The storage root retrieved from the provided state root\\n     */\\n    function getStorageRoot(BedrockStateProof memory proof) private pure returns (bytes32) {\\n        (bool exists, bytes memory encodedResolverAccount) = Lib_SecureMerkleTrie.get(\\n            abi.encodePacked(proof.target),\\n            proof.stateTrieWitness,\\n            proof.outputRootProof.stateRoot\\n        );\\n        /*\\n         * The account storage root has to be part of the provided state root\\n         * It might take some time for the state root to be posted on L1 after the transaction is included in a block\\n         * Until then, the account might not be part of the state root\\n         */\\n        require(exists, \\\"Account is not part of the provided state root\\\");\\n        RLPReader.RLPItem[] memory accountState = RLPReader.readList(encodedResolverAccount);\\n        return bytes32(RLPReader.readBytes(accountState[2]));\\n    }\\n\\n    /**\\n     * The slot values are padded with 0 so that they are 32 bytes long. This padding has to be returned so the returned value is the same length as the original value\\n     * @param result The concatenated result of all storage slots\\n     * @param length The length of the original value\\n     */\\n    function trimResult(bytes memory result, uint256 length) private pure returns (bytes memory) {\\n        if (length == 0) {\\n            return result;\\n        }\\n        return BytesLib.slice(result, 0, length);\\n    }\\n\\n    /**\\n     * @notice Get multiple storage proofs for the provided BedrockStateProof\\n     * @dev Dynamic Types like bytes, strings, or arrays are spread over multiple storage slots. This proves every storage slot the dynamic type contains and returns the concatenated result\\n     * @param proof The BedrockStateProof struct containing the necessary proof data\\n     * @return result The concatenated storage proofs for the provided BedrockStateProof\\n     */\\n    function getMultipleStorageProofs(BedrockStateProof memory proof) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(0);\\n        /*\\n         * The storage root of the account\\n         */\\n        bytes32 storageRoot = getStorageRoot(proof);\\n\\n        /*\\n         * For each sub storage proof, we are proving that the slot is included in the account root of the account\\n         */\\n        for (uint256 i = 0; i < proof.storageProofs.length; i++) {\\n            bytes memory slotValue = getSingleStorageProof(storageRoot, proof.storageProofs[i]);\\n            /*\\n             * Attach the current slot to the result\\n             */\\n            result = BytesLib.concat(result, slotValue);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @notice prove whether the provided storage slot is part of the storageRoot\\n     * @param storageRoot the storage root for the account that contains the storage slot\\n     * @param storageProof the StorageProof struct containing the necessary proof data\\n     * @return the retrieved storage proof value or 0x if the storage slot is empty\\n     */\\n    function getSingleStorageProof(bytes32 storageRoot, StorageProof memory storageProof) private pure returns (bytes memory) {\\n        (bool storageExists, bytes memory retrievedValue) = Lib_SecureMerkleTrie.get(\\n            abi.encodePacked(storageProof.key),\\n            storageProof.storageTrieWitness,\\n            storageRoot\\n        );\\n        /*\\n         * this means the storage slot is empty. So we can directly return 0x without RLP encoding it.\\n         */\\n        if (!storageExists) {\\n            return retrievedValue;\\n        }\\n        return RLPReader.readBytes(retrievedValue);\\n    }\\n}\\n\",\"keccak256\":\"0xed1e8bc28a6723d3668517b8eff8c8b8739f710c13a620bec61c14ece2d7f4d3\",\"license\":\"MIT\"},\"contracts/verifier/optimism-bedrock/IBedrockProofVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\nimport {Types} from \\\"@eth-optimism/contracts-bedrock/contracts/libraries/Types.sol\\\";\\n\\ninterface IBedrockProofVerifier {\\n    struct BedrockStateProof {\\n        uint8 layout;\\n        // the address of the contract we are trying to prove\\n        address target;\\n        // the length of the result\\n        uint256 length;\\n        // the state root of the account we are trying to prove\\n        bytes32 storageHash;\\n        // the accountProof RLP-Encoded\\n        bytes stateTrieWitness;\\n        // the output index the proof refers to\\n        uint256 l2OutputIndex;\\n        // the bedrock output RootProof struct\\n        Types.OutputRootProof outputRootProof;\\n        // the storage proofs for each slot included in the proof\\n        StorageProof[] storageProofs;\\n    }\\n    struct StorageProof {\\n        // the slot address\\n        bytes32 key;\\n        // the storageProof RLP-Encoded\\n        bytes storageTrieWitness;\\n    }\\n\\n    /// @notice returns the value of one or more storage slots given the provided proof is correct\\n    /// @param proof BedrockStateProof\\n    /// @return the value of all included slots concatenated\\n    function getProofValue(BedrockStateProof memory proof) external view returns (bytes memory);\\n}\\n\\ninterface IL2OutputOracle {\\n    function getL2Output(uint256 _l2OutputIndex) external view returns (Types.OutputProposal memory);\\n}\\n\",\"keccak256\":\"0x31616f5bfa4b6d9c3b4144a3a3b9bfd9236c4a750cb5cd2809750923a2aa90ab\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60a06040523462000040575b6200001f6200001962000106565b62000155565b604051612f6262000166823960805181818160d001526106e50152612f6290f35b62000049600080fd5b6200000b565b600080fd5b50634e487b7160e01b600052604160045260246000fd5b90601f01601f191681019081106001600160401b038211176200008d57604052565b6200009762000054565b604052565b90620000b3620000ab60405190565b92836200006b565b565b6001600160a01b031690565b90565b6001600160a01b038116036200004f57565b90505190620000b382620000c4565b90620000c19160208183031215620000d65762000100600080fd5b620000d6565b620000c1620030c8803803806200011d816200009c565b928339810190620000e5565b620000c190620000b5906001600160a01b031682565b620000c19062000129565b620000c1906200013f565b62000160906200014a565b60805256fe60806040526004361015610018575b610016600080fd5b005b60003560e01c80634d9f15591461004057638f46c50d0361000e5761003b61057d565b61000e565b5061003b6100b5565b600080fd5b600091031261005957565b610061600080fd5b565b6100779061007a906001600160a01b031682565b90565b6001600160a01b031690565b61007790610063565b61007790610086565b6100a19061008f565b9052565b6020810192916100619190610098565b50346100f9575b6100c736600461004e565b604051806100f57f0000000000000000000000000000000000000000000000000000000000000000826100a5565b0390f35b610101600080fd5b6100bc565b601f01601f191690565b50634e487b7160e01b600052604160045260246000fd5b90601f01601f1916810190811067ffffffffffffffff82111761014957604052565b610151610110565b604052565b9061006161016360405190565b9283610127565b60ff81165b0361004957565b905035906100618261016a565b61016f8161007a565b9050359061006182610183565b8061016f565b9050359061006182610199565b6101cb60209167ffffffffffffffff81116101cf57601f01601f191690565b0190565b610106610110565b90826000939282370152565b929190610061916101fb6101f6836101ac565b610156565b94828652602086019183820111156101d757610215600080fd5b6101d7565b906100779181601f82011215610236575b6020813591016101e3565b61023e600080fd5b61022b565b9190916080818403126102a3575b61029d61025e6080610156565b93600061026b828561019f565b90860152602061027d8282860161019f565b90860152604061028f8282860161019f565b90860152606080930161019f565b90830152565b6102ab600080fd5b610251565b6020809167ffffffffffffffff81116102c857020190565b6102d0610110565b020190565b919061031d90604084820312610331575b6102f06040610156565b9360006102fd838361019f565b9086015260208101359067ffffffffffffffff8211610324575b0161021a565b6020830152565b61032c600080fd5b610317565b610339600080fd5b6102e6565b9092919261034e6101f6826102b0565b93818552602080860192028301928184116103ae575b80925b848410610375575050505050565b6020809161039685873567ffffffffffffffff81116103a1575b86016102d5565b815201930192610367565b6103a9600080fd5b61038f565b6103b6600080fd5b610364565b906100779181601f820112156103d7575b60208135910161033e565b6103df600080fd5b6103cc565b91906104ae90610160848203126104cf575b610401610100610156565b93600061040e8383610176565b9086015260206104208382840161018c565b9086015260406104328382840161019f565b9086015260606104448382840161019f565b9086015261046882608083013567ffffffffffffffff81116104c2575b830161021a565b608086015260a061047b8382840161019f565b9086015260c061048d83828401610243565b908601526101408101359067ffffffffffffffff82116104b5575b016103bb565b60e0830152565b6104bd600080fd5b6104a8565b6104ca600080fd5b610461565b6104d7600080fd5b6103f6565b9061007791602081830312610512575b80359067ffffffffffffffff8211610505575b016103e4565b61050d600080fd5b6104ff565b61051a600080fd5b6104ec565b60005b8381106105325750506000910152565b8181015183820152602001610522565b6105636101066020936101cb93610557815190565b80835293849260200190565b9586910161051f565b602080825261007792910190610542565b50346105a6575b6100f561059a6105953660046104dc565b6106d3565b6040519182918261056c565b6105ae600080fd5b610584565b5190565b9050519061006182610199565b6fffffffffffffffffffffffffffffffff811661016f565b90505190610061826105c4565b919091606081840312610631575b61029d6106046060610156565b93600061061182856105b7565b908601526020610623828286016105dc565b9086015260408093016105dc565b610639600080fd5b6105f7565b9061007791606081830312156105e957610656600080fd5b6105e9565b506040513d6000823e3d90fd5b602080825260139082015272125b9d985b1a59081bdd5d1c1d5d081c9bdbdd606a1b604082015260600190565b1561069c57565b60405162461bcd60e51b8152806106b560048201610668565b0390fd5b5160ff1690565b6106cd6100776100779290565b60ff1690565b61077a61075d600061074360606107097f000000000000000000000000000000000000000000000000000000000000000061008f565b63a25ae5579061073561071e60a08a016105b3565b9261072860405190565b9586948593849360e01b90565b835260048301526024820190565b03915afa9081156107ee575b82916107c0575b50016105b3565b61077461077061007760c086015161082c565b9190565b14610695565b61078381610972565b9061078d816106b9565b6107a161079a60006106c0565b9160ff1690565b146107bc57906107b6604061007793016105b3565b906108a0565b5090565b6107e1915060603d81116107e7575b6107d98183610127565b81019061063e565b38610756565b503d6107cf565b6107f661065b565b61074f565b6108286100619461082160609498979561081a608086019a6000870152565b6020850152565b6040830152565b0152565b61087d610838826105b3565b610844602084016105b3565b906108716108606060610859604088016105b3565b96016105b3565b6040519586946020860194856107fb565b90810382520382610127565b61088f610888825190565b9160200190565b2090565b6100776100776100779290565b9060006108ac81610893565b82146108c557916108bf61007793610893565b90612e8c565b505090565b906108d76101f6836101ac565b918252565b369037565b906100616108f76108f1846108ca565b936101ac565b601f1901602084016108dc565b50634e487b7160e01b600052601160045260246000fd5b600190600019811461092b570190565b6101cb610904565b50634e487b7160e01b600052603260045260246000fd5b9060208091610957845190565b811015610965575b02010190565b61096d610933565b61095f565b9061097d6000610893565b610986816108e1565b9161099084610ac5565b91925b60e085016109a361007782515190565b8510156109dc576109ce60e0926109c86109c1886109d4955161094a565b5187612daf565b90612e1d565b9461091b565b939050610993565b509350915050565b610077905161007a565b60601b90565b610077906109ee565b610a096100a19161007a565b6109f4565b6101cb816014936109fd565b6020808252602e908201527f4163636f756e74206973206e6f742070617274206f66207468652070726f766960408201526d191959081cdd185d19481c9bdbdd60921b606082015260800190565b15610a6f57565b60405162461bcd60e51b8152806106b560048201610a1a565b610aa2610a9d610a96835190565b9260200190565b6105b3565b9060208110610aaf575090565b610ac190600019906020036008021b90565b1690565b610b53610b4d610b3d610b38610b3161007795610ae0600090565b50610aed602082016109e4565b90610b16610afa60405190565b8093610b0a602083019182610a0e565b90810382520383610127565b610b2b602060c06080840151930151016105b3565b91611992565b9190610a68565b610b58565b610b476002610893565b9061094a565b5161108d565b610a88565b610b6d61007791610b67606090565b50610c2a565b610e16565b6100776040610156565b610b84610b72565b906000825260006020830152565b610077610b7c565b6020808252604a908201527f524c505265616465723a206c656e677468206f6620616e20524c50206974656d60408201527f206d7573742062652067726561746572207468616e207a65726f20746f206265606082015269206465636f6461626c6560b01b608082015260a00190565b15610c1157565b60405162461bcd60e51b8152806106b560048201610b9a565b610c32610b92565b50610077610c3e825190565b91610c57600093610c5161077086610893565b11610c0a565b61031d610c6660208301925190565b610c6e610b72565b94850152565b50634e487b7160e01b600052602160045260246000fd5b60021115610c9557565b610061610c74565b9061006182610c8b565b60208082526038908201527f524c505265616465723a206465636f646564206974656d207479706520666f7260408201527f206c697374206973206e6f742061206c697374206974656d0000000000000000606082015260800190565b15610d0b57565b60405162461bcd60e51b8152806106b560048201610ca7565b91908201809211610d3157565b610061610904565b60208082526032908201527f524c505265616465723a206c697374206974656d2068617320616e20696e76616040820152713634b2103230ba30903932b6b0b4b73232b960711b606082015260800190565b15610d9257565b60405162461bcd60e51b8152806106b560048201610d39565b6100776020610893565b906108d76101f6836102b0565b60005b828110610dd157505050565b602090610ddc610b92565b8184015201610dc5565b90610061610dfc610df684610db5565b936102b0565b601f190160208401610dc2565b91908203918211610d3157565b610e4d610e62610e258361169a565b92919390610e47600194610e41610e3b87610c9d565b91610c9d565b14610d04565b84610d24565b610e5c610770610077876105b3565b14610d8b565b610e72610e6d610dab565b610de6565b92600082610e7f82610893565b94905b610e90575b50505050815290565b81830190610ea0610077836105b3565b811015610f965780610eb286936105b3565b90610ebc91610e09565b602085019082610ecb836105b3565b610ed490610893565b90610ede91610d24565b610ee790610893565b610eef610b72565b91610efa9087840152565b6020820152610f089061169a565b5097909183610f17848b610d24565b91610f21906105b3565b610f2a90610893565b90610f3491610d24565b610f3d90610893565b610f45610b72565b91610f509088840152565b6020820152610f5f828b61094a565b52610f6a818a61094a565b50610f7484610893565b610f7d91610d24565b96610f8791610d24565b610f9091610d24565b90610e82565b50610e87565b60208082526039908201527f524c505265616465723a206465636f646564206974656d207479706520666f7260408201527f206279746573206973206e6f7420612064617461206974656d00000000000000606082015260800190565b1561100057565b60405162461bcd60e51b8152806106b560048201610f9c565b60208082526034908201527f524c505265616465723a2062797465732076616c756520636f6e7461696e732060408201527330b71034b73b30b634b2103932b6b0b4b73232b960611b606082015260800190565b1561107457565b60405162461bcd60e51b8152806106b560048201611019565b6110e86110d26110ee6020610077946110a4606090565b506110ae8161169a565b6110cb60009893979298916110c5610e3b84610c9d565b14610ff9565b83016105b3565b6110e26107706100778989610d24565b1461106d565b016105b3565b611926565b6020808252604d90820152600080516020612f0d83398151915260408201527f74206265203e207468616e206c656e677468206f66206c697374206c656e677460608201526c6820286c6f6e67206c6973742960981b608082015260a00190565b1561115b57565b60405162461bcd60e51b8152806106b5600482016110f3565b6111876111816100779290565b60f81b90565b6001600160f81b03191690565b6020808252604890820152600080516020612f0d83398151915260408201527f74206e6f74206861766520616e79206c656164696e67207a65726f7320286c6f6060820152676e67206c6973742960c01b608082015260a00190565b156111f757565b60405162461bcd60e51b8152806106b560048201611194565b6020808252604690820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20353520627974657320286c6f6e67606082015265206c6973742960d01b608082015260a00190565b1561127157565b60405162461bcd60e51b8152806106b560048201611210565b6020808252604a90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20746f74616c206c656e67746820286060820152696c6f6e67206c6973742960b01b608082015260a00190565b156112ef57565b60405162461bcd60e51b8152806106b56004820161128a565b6020808252604a90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e206c697374206c656e677468202873606082015269686f7274206c6973742960b01b608082015260a00190565b1561136d57565b60405162461bcd60e51b8152806106b560048201611308565b6020808252605190820152600080516020612f0d83398151915260408201527f74206265203e207468616e206c656e677468206f6620737472696e67206c656e60608201527067746820286c6f6e6720737472696e672960781b608082015260a00190565b156113f257565b60405162461bcd60e51b8152806106b560048201611386565b6020808252604a90820152600080516020612f0d83398151915260408201527f74206e6f74206861766520616e79206c656164696e67207a65726f7320286c6f6060820152696e6720737472696e672960b01b608082015260a00190565b1561147057565b60405162461bcd60e51b8152806106b56004820161140b565b6020808252604890820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20353520627974657320286c6f6e6760608201526720737472696e672960c01b608082015260a00190565b156114ec57565b60405162461bcd60e51b8152806106b560048201611489565b6020808252604c90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20746f74616c206c656e677468202860608201526b6c6f6e6720737472696e672960a01b608082015260a00190565b1561156c57565b60405162461bcd60e51b8152806106b560048201611505565b6020808252604e90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20737472696e67206c656e6774682060608201526d2873686f727420737472696e672960901b608082015260a00190565b156115ee57565b60405162461bcd60e51b8152806106b560048201611585565b6020808252604d908201527f524c505265616465723a20696e76616c6964207072656669782c2073696e676c60408201527f652062797465203c203078383020617265206e6f74207072656669786564202860608201526c73686f727420737472696e672960981b608082015260a00190565b1561168157565b60405162461bcd60e51b8152806106b560048201611607565b6000906116a6816105b3565b916116b9600093610c5161077086610893565b6116c5602083016105b3565b8051841a916116d4607f610893565b83116116f357505050506001916107706116ed83610893565b93610893565b60b795939561170181610893565b84116117995750509061176961176e9261173b6117348761172d60809661172788610893565b90610e09565b99016105b3565b88106115e7565b6001908101519092906001600160f81b03191661175784610893565b881415918215611773575b505061167a565b610893565b929190565b61179091925061178290611174565b916001600160f81b03191690565b10153880611762565b6117a760bf97949297610893565b821161184957600161176e9493876117c861183a9561172761182496610893565b9501986117de6117d78b6105b3565b87106113eb565b81830151611803906001600160f81b0319166117fc6117828c611174565b1415611469565b50015183600802610100031c96610a9d61181d6037610893565b89116114e5565b6118346107706100778986610d24565b11611565565b6118446001610893565b610d24565b5091939460f761185881610893565b84116118925750505061188691929361187861187f9261172760c0610893565b94016105b3565b8310611366565b60019061176e82610893565b916001916118e0886118ad6119179761172761190198610893565b9801986118c36118bc8b6105b3565b8a10611154565b6118d961178260ff60f81b878701511692611174565b14156111f0565b50015184600802610100031c94610a9d6118fa6037610893565b871161126a565b6119116107706100778787610d24565b116112e8565b61176e60019261184484610893565b91611930816108e1565b9260009261193d84610893565b831461198b5761184461194f92610893565b81602085019184905b82821061197657501161196c575b50505090565b0152388080611966565b91508060209183015181850152018391611958565b5050505090565b906119a96119ae93926119a3600090565b50612aa2565b611a1b565b9091565b6020808252601a908201527f50726f76696465642070726f6f6620697320696e76616c69642e000000000000604082015260600190565b156119f057565b60405162461bcd60e51b8152806106b5600482016119b2565b61007760006108ca565b610077611a09565b90611a40611a669493611a39611a4893611a33600090565b506120b4565b9384611d29565b959192905190565b611a556107706000610893565b149485908615611a91575b506119e9565b8315611a875761007791610b47611a81926117276001610893565b51612a0f565b5050610077611a13565b905038611a60565b611aa1610b72565b906060825260606020830152565b610077611a99565b6020808252601a908201527f496e76616c696420696e7465726e616c206e6f64652068617368000000000000604082015260600190565b15611af557565b60405162461bcd60e51b8152806106b560048201611ab7565b6020808252601b908201527f496e76616c6964206c6172676520696e7465726e616c20686173680000000000604082015260600190565b15611b4c57565b60405162461bcd60e51b8152806106b560048201611b0e565b602080825260119082015270092dcecc2d8d2c840e4dedee840d0c2e6d607b1b604082015260600190565b15611b9757565b60405162461bcd60e51b8152806106b560048201611b65565b6100776010610893565b610077611bc5611bb0565b611bcf6001610893565b90610d24565b6100776002610893565b6020808252601d908201527f526563656976656420616e20756e706172736561626c65206e6f64652e000000604082015260600190565b906001602091610957845190565b516001600160f81b03191690565b6106cd6100776100779260ff1690565b6100779060f81c611c32565b50634e487b7160e01b600052601260045260246000fd5b611c719060ff1661079a565b908115611c7c570690565b611c84611c4e565b0690565b611c949060ff1661079a565b90039060ff8211610d3157565b6100776100776100779260ff1690565b61007760026106c0565b61007760036106c0565b61007760006106c0565b61007760016106c0565b60208082526026908201527f52656365697665642061206e6f6465207769746820616e20756e6b6e6f776e206040820152650e0e4caccd2f60d31b606082015260800190565b6100776080611174565b92906000611d3f611d3982610893565b92612cd6565b9390828096611d4c611aaf565b5081975b611d5b610077835190565b89101561206457611d7790611d708a8461094a565b5196610d24565b978895611d8e611d876001610893565b8095610d24565b99611d9886610893565b810361201b57611db886830151611db0610888825190565b208814611b90565b6020820191611dc683515190565b611dd4610770610077611bba565b03611e61575050611de66100778a5190565b8703611e1457505050505090610770915b611e0d610770610077611e08611d1f565b611187565b1493612aca565b8699939550611e4b611e5191610b47611e43611e3e611e39611e5897989a9c8f611c16565b611c24565b611c42565b915191611ca1565b51612982565b949161091b565b97949290611d50565b9094979650611e74829492969396515190565b611e82610770610077611bd5565b0361200257611e90906129e9565b94611ee0611eac611e3e611e39611ea687610893565b8a611c16565b96611eda611ed56002611ed0611eca611ec4836106c0565b8d611c65565b916106c0565b611c88565b611ca1565b90612aca565b97611eeb868c612aca565b94611ef6868b612a33565b97611f026106cd611cb1565b60ff8216148015611fec575b15611f6157505050505050611f24610770955190565b83149081611f56575b50611f45575b5050611f40611e08611d1f565b611df7565b611f4f9250610d24565b3880611f33565b518391501438611f2d565b91949899929550929550611f766106cd611cc5565b60ff821614908115611fd5575b5015611fbc57518514611fa55750505050505061077090611f40611e08611d1f565b611e4b611e5892611e51929b959697989b5161094a565b60405162461bcd60e51b8152806106b560048201611cd9565b9050611fe561079a6106cd611ccf565b1438611f83565b50611ff86106cd611cbb565b60ff821614611f0e565b60405162461bcd60e51b8152806106b560048201611bdf565b81860180515161202e6107706020610893565b106120505761204b9051612043610888825190565b208814611b45565b611db8565b61205d61204b9151612c5c565b8814611aee565b50509550509061077091611df7565b60005b82811061208257505050565b60209061208d611aaf565b8184015201612076565b906100616120a7610df684610db5565b601f190160208401612073565b6120bd90612141565b6120cd6120c8825190565b612097565b906000906120da82610893565b6120e5610077835190565b81101561196657806121036120fd61213c938561094a565b5161242d565b61212161210f82612141565b61031d61211a610b72565b9388850152565b61212b828761094a565b52612136818661094a565b5061091b565b6120da565b61215661007791612150606090565b5061215b565b612286565b612163610b92565b5061007761217360208301925190565b9161031d61217f610b72565b938452565b60208082526017908201527f496e76616c696420524c50206c6973742076616c75652e000000000000000000604082015260600190565b156121c257565b60405162461bcd60e51b8152806106b560048201612184565b60005b8281106121ea57505050565b6020906121f5610b92565b81840152016121de565b9061006161220f610df684610db5565b601f1901602084016121db565b6020808252602a908201527f50726f766964656420524c50206c6973742065786365656473206d6178206c6960408201526939ba103632b733ba341760b11b606082015260800190565b1561226d57565b60405162461bcd60e51b8152806106b56004820161221c565b61228f816126b9565b90506122a96001916122a3610e3b84610c9d565b146121bb565b6122b1610dab565b926122bb846121ff565b93826000916122c983610893565b95915b6122db575b5050505050815290565b828401916122eb610077846105b3565b8110156123d0578086936122fc8490565b891061230790612266565b612310906105b3565b9061231a91610e09565b602086019082612329836105b3565b9061233391610d24565b61233b610b72565b916123469088840152565b6020820152612354906126b9565b5098909183612363848c610d24565b9161236d906105b3565b9061237791610d24565b61237f610b72565b9161238a9089840152565b6020820152612399828c61094a565b526123a4818b61094a565b506123ae85610893565b6123b791610d24565b976123c191610d24565b6123ca91610d24565b916122cc565b506122d1565b60208082526018908201527f496e76616c696420524c502062797465732076616c75652e0000000000000000604082015260600190565b1561241457565b60405162461bcd60e51b8152806106b5600482016123d6565b610077906110e861245a6020612442846126b9565b612454610e3b60009894979398610c9d565b1461240d565b612888565b60208082526018908201527f524c50206974656d2063616e6e6f74206265206e756c6c2e0000000000000000604082015260600190565b1561249d57565b60405162461bcd60e51b8152806106b56004820161245f565b6020808252601d908201527f496e76616c696420524c50206c6f6e67206c697374206c656e6774682e000000604082015260600190565b156124f457565b60405162461bcd60e51b8152806106b5600482016124b6565b60208082526016908201527524b73b30b634b210292628103637b733903634b9ba1760511b604082015260600190565b1561254457565b60405162461bcd60e51b8152806106b56004820161250d565b60208082526017908201527f496e76616c696420524c502073686f7274206c6973742e000000000000000000604082015260600190565b1561259b57565b60405162461bcd60e51b8152806106b56004820161255d565b6020808252601f908201527f496e76616c696420524c50206c6f6e6720737472696e67206c656e6774682e00604082015260600190565b156125f257565b60405162461bcd60e51b8152806106b5600482016125b4565b60208082526018908201527f496e76616c696420524c50206c6f6e6720737472696e672e0000000000000000604082015260600190565b1561264957565b60405162461bcd60e51b8152806106b56004820161260b565b60208082526019908201527f496e76616c696420524c502073686f727420737472696e672e00000000000000604082015260600190565b156126a057565b60405162461bcd60e51b8152806106b560048201612662565b6000906126c5816105b3565b916126de6000936126d861077086610893565b11612496565b6126ea602083016105b3565b908151841a916126fa607f610893565b831161271357505050506001916107706116ed83610893565b60b795939561272181610893565b8411612757575050506127468361273f61274d936117276080610893565b95016105b3565b8410612699565b61176e6001610893565b61276660bf9794929397610893565b82116127c65761176e93928661278561183a946117276127b095610893565b94019761279b6127948a6105b3565b86106125eb565b506001846020036101000a91015104966105b3565b6127c06107706100778986610d24565b11612642565b5091949060f79493946127d881610893565b84116127fd57505050611886916118786127f69261172760c0610893565b8310612594565b936128146119179461172761283f95999897610893565b95019561282a612823886105b3565b87106124ed565b506001856020036101000a91015104946105b3565b61284f6107706100778787610d24565b1161253d565b811561285f570490565b612867611c4e565b0490565b90611c71565b0390565b906128836107706100779390565b900a90565b90612892836108e1565b9061289b825190565b926000936128ab61077086610893565b1461297a57906128bd91959395610d24565b916000916128ce6020820196610893565b935b60206128e76100776128e183610893565b89612855565b861015612919578161290c6129056109ce9361291295518c52610893565b8092610d24565b98610d24565b93956128d0565b509261296b929694509461295b91955061295661294b6101009261295161294b60209261294584610893565b9061286b565b91610893565b612871565b612875565b6129656001610893565b90612871565b82519151811916911617905290565b505091505090565b6100779061298f816105b3565b61299c6107706020610893565b10156129b0576129ab906129b9565b612c5c565b6129ab9061242d565b61007790610077906129cd602082016105b3565b6129e36129dd60008094016105b3565b92610893565b90612888565b612a0a6120fd6020610077936129fd606090565b500151610b476000610893565b612cd6565b6120fd602061007792612a20606090565b5001518051610b47906117276001610893565b612a3d6000610893565b8151811080612a8d575b80612a66575b15612a6057612a5b9061091b565b612a3d565b91505090565b50612a74611e398284611c16565b612a87611782611187611e398588611c16565b14612a4d565b5082518110612a47565b6101cb816020939052565b612aad610888825190565b20610077612aba60405190565b8092610871602083019182612a97565b612ad5610077825190565b821015611a875781612af161007793612aec845190565b610e09565b91612b8a565b6020808252600e908201526d736c6963655f6f766572666c6f7760901b604082015260600190565b15612b2657565b60405162461bcd60e51b8152806106b560048201612af7565b602080825260119082015270736c6963655f6f75744f66426f756e647360781b604082015260600190565b15612b7157565b60405162461bcd60e51b8152806106b560048201612b3f565b9091601f906060612baa612ba0610e4785610893565b83905b1015612b1f565b612bbe612bb78387610d24565b8690612ba3565b612be0612bc9855190565b612bd9610770610077868a610d24565b1015612b6a565b5080612bfb5750505050604051600081526020810160405290565b60405193828216801560200281870181019590910101018382015b808510612c2c5750508352801991011660405290565b9093602080918651815201940190612c16565b9061007791602081830312156105b757612c57600080fd5b6105b7565b600090612c67815190565b91602092612c7761077085610893565b10612c94575061007791612c89825190565b818301019101612c3f565b50015190565b81810292918115918404141715610d3157565b61118790612cc16117826100779460ff1690565b901c90565b6111876111816100779260ff1690565b908151612cf6612cf1600292612ceb84610893565b90612c9a565b6108e1565b90600093612d0385610893565b612d0e610077835190565b811015612da75780612d39612d29611e39612da29486611c16565b612d3360046106c0565b90612cad565b612d58612d4e612d4887610893565b84612c9a565b91891a9187611c16565b53612d84612d7f612d6f611e3e611e398588611c16565b612d7960106106c0565b90611c65565b612cc6565b612d9c612d4e611bc5612d9688610893565b85612c9a565b5361091b565b612d03565b509193505050565b612dfb90612e0192612dbf606090565b506020612dcb826105b3565b91612df3612dd860405190565b8094612de78583019182612a97565b90810382520384610127565b015190611992565b91901590565b6100775761007790612e1861007791610b67606090565b61108d565b604051918151808452602084019081019060208401905b828110612e7c57505081519084518201855260208282019301905b838110612e6c57505091519091011501601f01601f191660405290565b8151815260209182019101612e4f565b8151815260209182019101612e34565b9091601f906060612ea2612ba0610e4785610893565b612ead612bc9855190565b5080612ec85750505050604051600081526020810160405290565b60405193828216801560200281870181019590910101018382015b808510612ef95750508352801991011660405290565b9093602080918651815201940190612ee356fe524c505265616465723a206c656e677468206f6620636f6e74656e74206d7573a2646970667358221220450bd3030b39f31fe3c3c9d5ca0e0d46020206e442888ad8315b9f89b60490b364736f6c63430008110033",
  "deployedBytecode": "0x60806040526004361015610018575b610016600080fd5b005b60003560e01c80634d9f15591461004057638f46c50d0361000e5761003b61057d565b61000e565b5061003b6100b5565b600080fd5b600091031261005957565b610061600080fd5b565b6100779061007a906001600160a01b031682565b90565b6001600160a01b031690565b61007790610063565b61007790610086565b6100a19061008f565b9052565b6020810192916100619190610098565b50346100f9575b6100c736600461004e565b604051806100f57f0000000000000000000000000000000000000000000000000000000000000000826100a5565b0390f35b610101600080fd5b6100bc565b601f01601f191690565b50634e487b7160e01b600052604160045260246000fd5b90601f01601f1916810190811067ffffffffffffffff82111761014957604052565b610151610110565b604052565b9061006161016360405190565b9283610127565b60ff81165b0361004957565b905035906100618261016a565b61016f8161007a565b9050359061006182610183565b8061016f565b9050359061006182610199565b6101cb60209167ffffffffffffffff81116101cf57601f01601f191690565b0190565b610106610110565b90826000939282370152565b929190610061916101fb6101f6836101ac565b610156565b94828652602086019183820111156101d757610215600080fd5b6101d7565b906100779181601f82011215610236575b6020813591016101e3565b61023e600080fd5b61022b565b9190916080818403126102a3575b61029d61025e6080610156565b93600061026b828561019f565b90860152602061027d8282860161019f565b90860152604061028f8282860161019f565b90860152606080930161019f565b90830152565b6102ab600080fd5b610251565b6020809167ffffffffffffffff81116102c857020190565b6102d0610110565b020190565b919061031d90604084820312610331575b6102f06040610156565b9360006102fd838361019f565b9086015260208101359067ffffffffffffffff8211610324575b0161021a565b6020830152565b61032c600080fd5b610317565b610339600080fd5b6102e6565b9092919261034e6101f6826102b0565b93818552602080860192028301928184116103ae575b80925b848410610375575050505050565b6020809161039685873567ffffffffffffffff81116103a1575b86016102d5565b815201930192610367565b6103a9600080fd5b61038f565b6103b6600080fd5b610364565b906100779181601f820112156103d7575b60208135910161033e565b6103df600080fd5b6103cc565b91906104ae90610160848203126104cf575b610401610100610156565b93600061040e8383610176565b9086015260206104208382840161018c565b9086015260406104328382840161019f565b9086015260606104448382840161019f565b9086015261046882608083013567ffffffffffffffff81116104c2575b830161021a565b608086015260a061047b8382840161019f565b9086015260c061048d83828401610243565b908601526101408101359067ffffffffffffffff82116104b5575b016103bb565b60e0830152565b6104bd600080fd5b6104a8565b6104ca600080fd5b610461565b6104d7600080fd5b6103f6565b9061007791602081830312610512575b80359067ffffffffffffffff8211610505575b016103e4565b61050d600080fd5b6104ff565b61051a600080fd5b6104ec565b60005b8381106105325750506000910152565b8181015183820152602001610522565b6105636101066020936101cb93610557815190565b80835293849260200190565b9586910161051f565b602080825261007792910190610542565b50346105a6575b6100f561059a6105953660046104dc565b6106d3565b6040519182918261056c565b6105ae600080fd5b610584565b5190565b9050519061006182610199565b6fffffffffffffffffffffffffffffffff811661016f565b90505190610061826105c4565b919091606081840312610631575b61029d6106046060610156565b93600061061182856105b7565b908601526020610623828286016105dc565b9086015260408093016105dc565b610639600080fd5b6105f7565b9061007791606081830312156105e957610656600080fd5b6105e9565b506040513d6000823e3d90fd5b602080825260139082015272125b9d985b1a59081bdd5d1c1d5d081c9bdbdd606a1b604082015260600190565b1561069c57565b60405162461bcd60e51b8152806106b560048201610668565b0390fd5b5160ff1690565b6106cd6100776100779290565b60ff1690565b61077a61075d600061074360606107097f000000000000000000000000000000000000000000000000000000000000000061008f565b63a25ae5579061073561071e60a08a016105b3565b9261072860405190565b9586948593849360e01b90565b835260048301526024820190565b03915afa9081156107ee575b82916107c0575b50016105b3565b61077461077061007760c086015161082c565b9190565b14610695565b61078381610972565b9061078d816106b9565b6107a161079a60006106c0565b9160ff1690565b146107bc57906107b6604061007793016105b3565b906108a0565b5090565b6107e1915060603d81116107e7575b6107d98183610127565b81019061063e565b38610756565b503d6107cf565b6107f661065b565b61074f565b6108286100619461082160609498979561081a608086019a6000870152565b6020850152565b6040830152565b0152565b61087d610838826105b3565b610844602084016105b3565b906108716108606060610859604088016105b3565b96016105b3565b6040519586946020860194856107fb565b90810382520382610127565b61088f610888825190565b9160200190565b2090565b6100776100776100779290565b9060006108ac81610893565b82146108c557916108bf61007793610893565b90612e8c565b505090565b906108d76101f6836101ac565b918252565b369037565b906100616108f76108f1846108ca565b936101ac565b601f1901602084016108dc565b50634e487b7160e01b600052601160045260246000fd5b600190600019811461092b570190565b6101cb610904565b50634e487b7160e01b600052603260045260246000fd5b9060208091610957845190565b811015610965575b02010190565b61096d610933565b61095f565b9061097d6000610893565b610986816108e1565b9161099084610ac5565b91925b60e085016109a361007782515190565b8510156109dc576109ce60e0926109c86109c1886109d4955161094a565b5187612daf565b90612e1d565b9461091b565b939050610993565b509350915050565b610077905161007a565b60601b90565b610077906109ee565b610a096100a19161007a565b6109f4565b6101cb816014936109fd565b6020808252602e908201527f4163636f756e74206973206e6f742070617274206f66207468652070726f766960408201526d191959081cdd185d19481c9bdbdd60921b606082015260800190565b15610a6f57565b60405162461bcd60e51b8152806106b560048201610a1a565b610aa2610a9d610a96835190565b9260200190565b6105b3565b9060208110610aaf575090565b610ac190600019906020036008021b90565b1690565b610b53610b4d610b3d610b38610b3161007795610ae0600090565b50610aed602082016109e4565b90610b16610afa60405190565b8093610b0a602083019182610a0e565b90810382520383610127565b610b2b602060c06080840151930151016105b3565b91611992565b9190610a68565b610b58565b610b476002610893565b9061094a565b5161108d565b610a88565b610b6d61007791610b67606090565b50610c2a565b610e16565b6100776040610156565b610b84610b72565b906000825260006020830152565b610077610b7c565b6020808252604a908201527f524c505265616465723a206c656e677468206f6620616e20524c50206974656d60408201527f206d7573742062652067726561746572207468616e207a65726f20746f206265606082015269206465636f6461626c6560b01b608082015260a00190565b15610c1157565b60405162461bcd60e51b8152806106b560048201610b9a565b610c32610b92565b50610077610c3e825190565b91610c57600093610c5161077086610893565b11610c0a565b61031d610c6660208301925190565b610c6e610b72565b94850152565b50634e487b7160e01b600052602160045260246000fd5b60021115610c9557565b610061610c74565b9061006182610c8b565b60208082526038908201527f524c505265616465723a206465636f646564206974656d207479706520666f7260408201527f206c697374206973206e6f742061206c697374206974656d0000000000000000606082015260800190565b15610d0b57565b60405162461bcd60e51b8152806106b560048201610ca7565b91908201809211610d3157565b610061610904565b60208082526032908201527f524c505265616465723a206c697374206974656d2068617320616e20696e76616040820152713634b2103230ba30903932b6b0b4b73232b960711b606082015260800190565b15610d9257565b60405162461bcd60e51b8152806106b560048201610d39565b6100776020610893565b906108d76101f6836102b0565b60005b828110610dd157505050565b602090610ddc610b92565b8184015201610dc5565b90610061610dfc610df684610db5565b936102b0565b601f190160208401610dc2565b91908203918211610d3157565b610e4d610e62610e258361169a565b92919390610e47600194610e41610e3b87610c9d565b91610c9d565b14610d04565b84610d24565b610e5c610770610077876105b3565b14610d8b565b610e72610e6d610dab565b610de6565b92600082610e7f82610893565b94905b610e90575b50505050815290565b81830190610ea0610077836105b3565b811015610f965780610eb286936105b3565b90610ebc91610e09565b602085019082610ecb836105b3565b610ed490610893565b90610ede91610d24565b610ee790610893565b610eef610b72565b91610efa9087840152565b6020820152610f089061169a565b5097909183610f17848b610d24565b91610f21906105b3565b610f2a90610893565b90610f3491610d24565b610f3d90610893565b610f45610b72565b91610f509088840152565b6020820152610f5f828b61094a565b52610f6a818a61094a565b50610f7484610893565b610f7d91610d24565b96610f8791610d24565b610f9091610d24565b90610e82565b50610e87565b60208082526039908201527f524c505265616465723a206465636f646564206974656d207479706520666f7260408201527f206279746573206973206e6f7420612064617461206974656d00000000000000606082015260800190565b1561100057565b60405162461bcd60e51b8152806106b560048201610f9c565b60208082526034908201527f524c505265616465723a2062797465732076616c756520636f6e7461696e732060408201527330b71034b73b30b634b2103932b6b0b4b73232b960611b606082015260800190565b1561107457565b60405162461bcd60e51b8152806106b560048201611019565b6110e86110d26110ee6020610077946110a4606090565b506110ae8161169a565b6110cb60009893979298916110c5610e3b84610c9d565b14610ff9565b83016105b3565b6110e26107706100778989610d24565b1461106d565b016105b3565b611926565b6020808252604d90820152600080516020612f0d83398151915260408201527f74206265203e207468616e206c656e677468206f66206c697374206c656e677460608201526c6820286c6f6e67206c6973742960981b608082015260a00190565b1561115b57565b60405162461bcd60e51b8152806106b5600482016110f3565b6111876111816100779290565b60f81b90565b6001600160f81b03191690565b6020808252604890820152600080516020612f0d83398151915260408201527f74206e6f74206861766520616e79206c656164696e67207a65726f7320286c6f6060820152676e67206c6973742960c01b608082015260a00190565b156111f757565b60405162461bcd60e51b8152806106b560048201611194565b6020808252604690820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20353520627974657320286c6f6e67606082015265206c6973742960d01b608082015260a00190565b1561127157565b60405162461bcd60e51b8152806106b560048201611210565b6020808252604a90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20746f74616c206c656e67746820286060820152696c6f6e67206c6973742960b01b608082015260a00190565b156112ef57565b60405162461bcd60e51b8152806106b56004820161128a565b6020808252604a90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e206c697374206c656e677468202873606082015269686f7274206c6973742960b01b608082015260a00190565b1561136d57565b60405162461bcd60e51b8152806106b560048201611308565b6020808252605190820152600080516020612f0d83398151915260408201527f74206265203e207468616e206c656e677468206f6620737472696e67206c656e60608201527067746820286c6f6e6720737472696e672960781b608082015260a00190565b156113f257565b60405162461bcd60e51b8152806106b560048201611386565b6020808252604a90820152600080516020612f0d83398151915260408201527f74206e6f74206861766520616e79206c656164696e67207a65726f7320286c6f6060820152696e6720737472696e672960b01b608082015260a00190565b1561147057565b60405162461bcd60e51b8152806106b56004820161140b565b6020808252604890820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20353520627974657320286c6f6e6760608201526720737472696e672960c01b608082015260a00190565b156114ec57565b60405162461bcd60e51b8152806106b560048201611489565b6020808252604c90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20746f74616c206c656e677468202860608201526b6c6f6e6720737472696e672960a01b608082015260a00190565b1561156c57565b60405162461bcd60e51b8152806106b560048201611505565b6020808252604e90820152600080516020612f0d83398151915260408201527f742062652067726561746572207468616e20737472696e67206c656e6774682060608201526d2873686f727420737472696e672960901b608082015260a00190565b156115ee57565b60405162461bcd60e51b8152806106b560048201611585565b6020808252604d908201527f524c505265616465723a20696e76616c6964207072656669782c2073696e676c60408201527f652062797465203c203078383020617265206e6f74207072656669786564202860608201526c73686f727420737472696e672960981b608082015260a00190565b1561168157565b60405162461bcd60e51b8152806106b560048201611607565b6000906116a6816105b3565b916116b9600093610c5161077086610893565b6116c5602083016105b3565b8051841a916116d4607f610893565b83116116f357505050506001916107706116ed83610893565b93610893565b60b795939561170181610893565b84116117995750509061176961176e9261173b6117348761172d60809661172788610893565b90610e09565b99016105b3565b88106115e7565b6001908101519092906001600160f81b03191661175784610893565b881415918215611773575b505061167a565b610893565b929190565b61179091925061178290611174565b916001600160f81b03191690565b10153880611762565b6117a760bf97949297610893565b821161184957600161176e9493876117c861183a9561172761182496610893565b9501986117de6117d78b6105b3565b87106113eb565b81830151611803906001600160f81b0319166117fc6117828c611174565b1415611469565b50015183600802610100031c96610a9d61181d6037610893565b89116114e5565b6118346107706100778986610d24565b11611565565b6118446001610893565b610d24565b5091939460f761185881610893565b84116118925750505061188691929361187861187f9261172760c0610893565b94016105b3565b8310611366565b60019061176e82610893565b916001916118e0886118ad6119179761172761190198610893565b9801986118c36118bc8b6105b3565b8a10611154565b6118d961178260ff60f81b878701511692611174565b14156111f0565b50015184600802610100031c94610a9d6118fa6037610893565b871161126a565b6119116107706100778787610d24565b116112e8565b61176e60019261184484610893565b91611930816108e1565b9260009261193d84610893565b831461198b5761184461194f92610893565b81602085019184905b82821061197657501161196c575b50505090565b0152388080611966565b91508060209183015181850152018391611958565b5050505090565b906119a96119ae93926119a3600090565b50612aa2565b611a1b565b9091565b6020808252601a908201527f50726f76696465642070726f6f6620697320696e76616c69642e000000000000604082015260600190565b156119f057565b60405162461bcd60e51b8152806106b5600482016119b2565b61007760006108ca565b610077611a09565b90611a40611a669493611a39611a4893611a33600090565b506120b4565b9384611d29565b959192905190565b611a556107706000610893565b149485908615611a91575b506119e9565b8315611a875761007791610b47611a81926117276001610893565b51612a0f565b5050610077611a13565b905038611a60565b611aa1610b72565b906060825260606020830152565b610077611a99565b6020808252601a908201527f496e76616c696420696e7465726e616c206e6f64652068617368000000000000604082015260600190565b15611af557565b60405162461bcd60e51b8152806106b560048201611ab7565b6020808252601b908201527f496e76616c6964206c6172676520696e7465726e616c20686173680000000000604082015260600190565b15611b4c57565b60405162461bcd60e51b8152806106b560048201611b0e565b602080825260119082015270092dcecc2d8d2c840e4dedee840d0c2e6d607b1b604082015260600190565b15611b9757565b60405162461bcd60e51b8152806106b560048201611b65565b6100776010610893565b610077611bc5611bb0565b611bcf6001610893565b90610d24565b6100776002610893565b6020808252601d908201527f526563656976656420616e20756e706172736561626c65206e6f64652e000000604082015260600190565b906001602091610957845190565b516001600160f81b03191690565b6106cd6100776100779260ff1690565b6100779060f81c611c32565b50634e487b7160e01b600052601260045260246000fd5b611c719060ff1661079a565b908115611c7c570690565b611c84611c4e565b0690565b611c949060ff1661079a565b90039060ff8211610d3157565b6100776100776100779260ff1690565b61007760026106c0565b61007760036106c0565b61007760006106c0565b61007760016106c0565b60208082526026908201527f52656365697665642061206e6f6465207769746820616e20756e6b6e6f776e206040820152650e0e4caccd2f60d31b606082015260800190565b6100776080611174565b92906000611d3f611d3982610893565b92612cd6565b9390828096611d4c611aaf565b5081975b611d5b610077835190565b89101561206457611d7790611d708a8461094a565b5196610d24565b978895611d8e611d876001610893565b8095610d24565b99611d9886610893565b810361201b57611db886830151611db0610888825190565b208814611b90565b6020820191611dc683515190565b611dd4610770610077611bba565b03611e61575050611de66100778a5190565b8703611e1457505050505090610770915b611e0d610770610077611e08611d1f565b611187565b1493612aca565b8699939550611e4b611e5191610b47611e43611e3e611e39611e5897989a9c8f611c16565b611c24565b611c42565b915191611ca1565b51612982565b949161091b565b97949290611d50565b9094979650611e74829492969396515190565b611e82610770610077611bd5565b0361200257611e90906129e9565b94611ee0611eac611e3e611e39611ea687610893565b8a611c16565b96611eda611ed56002611ed0611eca611ec4836106c0565b8d611c65565b916106c0565b611c88565b611ca1565b90612aca565b97611eeb868c612aca565b94611ef6868b612a33565b97611f026106cd611cb1565b60ff8216148015611fec575b15611f6157505050505050611f24610770955190565b83149081611f56575b50611f45575b5050611f40611e08611d1f565b611df7565b611f4f9250610d24565b3880611f33565b518391501438611f2d565b91949899929550929550611f766106cd611cc5565b60ff821614908115611fd5575b5015611fbc57518514611fa55750505050505061077090611f40611e08611d1f565b611e4b611e5892611e51929b959697989b5161094a565b60405162461bcd60e51b8152806106b560048201611cd9565b9050611fe561079a6106cd611ccf565b1438611f83565b50611ff86106cd611cbb565b60ff821614611f0e565b60405162461bcd60e51b8152806106b560048201611bdf565b81860180515161202e6107706020610893565b106120505761204b9051612043610888825190565b208814611b45565b611db8565b61205d61204b9151612c5c565b8814611aee565b50509550509061077091611df7565b60005b82811061208257505050565b60209061208d611aaf565b8184015201612076565b906100616120a7610df684610db5565b601f190160208401612073565b6120bd90612141565b6120cd6120c8825190565b612097565b906000906120da82610893565b6120e5610077835190565b81101561196657806121036120fd61213c938561094a565b5161242d565b61212161210f82612141565b61031d61211a610b72565b9388850152565b61212b828761094a565b52612136818661094a565b5061091b565b6120da565b61215661007791612150606090565b5061215b565b612286565b612163610b92565b5061007761217360208301925190565b9161031d61217f610b72565b938452565b60208082526017908201527f496e76616c696420524c50206c6973742076616c75652e000000000000000000604082015260600190565b156121c257565b60405162461bcd60e51b8152806106b560048201612184565b60005b8281106121ea57505050565b6020906121f5610b92565b81840152016121de565b9061006161220f610df684610db5565b601f1901602084016121db565b6020808252602a908201527f50726f766964656420524c50206c6973742065786365656473206d6178206c6960408201526939ba103632b733ba341760b11b606082015260800190565b1561226d57565b60405162461bcd60e51b8152806106b56004820161221c565b61228f816126b9565b90506122a96001916122a3610e3b84610c9d565b146121bb565b6122b1610dab565b926122bb846121ff565b93826000916122c983610893565b95915b6122db575b5050505050815290565b828401916122eb610077846105b3565b8110156123d0578086936122fc8490565b891061230790612266565b612310906105b3565b9061231a91610e09565b602086019082612329836105b3565b9061233391610d24565b61233b610b72565b916123469088840152565b6020820152612354906126b9565b5098909183612363848c610d24565b9161236d906105b3565b9061237791610d24565b61237f610b72565b9161238a9089840152565b6020820152612399828c61094a565b526123a4818b61094a565b506123ae85610893565b6123b791610d24565b976123c191610d24565b6123ca91610d24565b916122cc565b506122d1565b60208082526018908201527f496e76616c696420524c502062797465732076616c75652e0000000000000000604082015260600190565b1561241457565b60405162461bcd60e51b8152806106b5600482016123d6565b610077906110e861245a6020612442846126b9565b612454610e3b60009894979398610c9d565b1461240d565b612888565b60208082526018908201527f524c50206974656d2063616e6e6f74206265206e756c6c2e0000000000000000604082015260600190565b1561249d57565b60405162461bcd60e51b8152806106b56004820161245f565b6020808252601d908201527f496e76616c696420524c50206c6f6e67206c697374206c656e6774682e000000604082015260600190565b156124f457565b60405162461bcd60e51b8152806106b5600482016124b6565b60208082526016908201527524b73b30b634b210292628103637b733903634b9ba1760511b604082015260600190565b1561254457565b60405162461bcd60e51b8152806106b56004820161250d565b60208082526017908201527f496e76616c696420524c502073686f7274206c6973742e000000000000000000604082015260600190565b1561259b57565b60405162461bcd60e51b8152806106b56004820161255d565b6020808252601f908201527f496e76616c696420524c50206c6f6e6720737472696e67206c656e6774682e00604082015260600190565b156125f257565b60405162461bcd60e51b8152806106b5600482016125b4565b60208082526018908201527f496e76616c696420524c50206c6f6e6720737472696e672e0000000000000000604082015260600190565b1561264957565b60405162461bcd60e51b8152806106b56004820161260b565b60208082526019908201527f496e76616c696420524c502073686f727420737472696e672e00000000000000604082015260600190565b156126a057565b60405162461bcd60e51b8152806106b560048201612662565b6000906126c5816105b3565b916126de6000936126d861077086610893565b11612496565b6126ea602083016105b3565b908151841a916126fa607f610893565b831161271357505050506001916107706116ed83610893565b60b795939561272181610893565b8411612757575050506127468361273f61274d936117276080610893565b95016105b3565b8410612699565b61176e6001610893565b61276660bf9794929397610893565b82116127c65761176e93928661278561183a946117276127b095610893565b94019761279b6127948a6105b3565b86106125eb565b506001846020036101000a91015104966105b3565b6127c06107706100778986610d24565b11612642565b5091949060f79493946127d881610893565b84116127fd57505050611886916118786127f69261172760c0610893565b8310612594565b936128146119179461172761283f95999897610893565b95019561282a612823886105b3565b87106124ed565b506001856020036101000a91015104946105b3565b61284f6107706100778787610d24565b1161253d565b811561285f570490565b612867611c4e565b0490565b90611c71565b0390565b906128836107706100779390565b900a90565b90612892836108e1565b9061289b825190565b926000936128ab61077086610893565b1461297a57906128bd91959395610d24565b916000916128ce6020820196610893565b935b60206128e76100776128e183610893565b89612855565b861015612919578161290c6129056109ce9361291295518c52610893565b8092610d24565b98610d24565b93956128d0565b509261296b929694509461295b91955061295661294b6101009261295161294b60209261294584610893565b9061286b565b91610893565b612871565b612875565b6129656001610893565b90612871565b82519151811916911617905290565b505091505090565b6100779061298f816105b3565b61299c6107706020610893565b10156129b0576129ab906129b9565b612c5c565b6129ab9061242d565b61007790610077906129cd602082016105b3565b6129e36129dd60008094016105b3565b92610893565b90612888565b612a0a6120fd6020610077936129fd606090565b500151610b476000610893565b612cd6565b6120fd602061007792612a20606090565b5001518051610b47906117276001610893565b612a3d6000610893565b8151811080612a8d575b80612a66575b15612a6057612a5b9061091b565b612a3d565b91505090565b50612a74611e398284611c16565b612a87611782611187611e398588611c16565b14612a4d565b5082518110612a47565b6101cb816020939052565b612aad610888825190565b20610077612aba60405190565b8092610871602083019182612a97565b612ad5610077825190565b821015611a875781612af161007793612aec845190565b610e09565b91612b8a565b6020808252600e908201526d736c6963655f6f766572666c6f7760901b604082015260600190565b15612b2657565b60405162461bcd60e51b8152806106b560048201612af7565b602080825260119082015270736c6963655f6f75744f66426f756e647360781b604082015260600190565b15612b7157565b60405162461bcd60e51b8152806106b560048201612b3f565b9091601f906060612baa612ba0610e4785610893565b83905b1015612b1f565b612bbe612bb78387610d24565b8690612ba3565b612be0612bc9855190565b612bd9610770610077868a610d24565b1015612b6a565b5080612bfb5750505050604051600081526020810160405290565b60405193828216801560200281870181019590910101018382015b808510612c2c5750508352801991011660405290565b9093602080918651815201940190612c16565b9061007791602081830312156105b757612c57600080fd5b6105b7565b600090612c67815190565b91602092612c7761077085610893565b10612c94575061007791612c89825190565b818301019101612c3f565b50015190565b81810292918115918404141715610d3157565b61118790612cc16117826100779460ff1690565b901c90565b6111876111816100779260ff1690565b908151612cf6612cf1600292612ceb84610893565b90612c9a565b6108e1565b90600093612d0385610893565b612d0e610077835190565b811015612da75780612d39612d29611e39612da29486611c16565b612d3360046106c0565b90612cad565b612d58612d4e612d4887610893565b84612c9a565b91891a9187611c16565b53612d84612d7f612d6f611e3e611e398588611c16565b612d7960106106c0565b90611c65565b612cc6565b612d9c612d4e611bc5612d9688610893565b85612c9a565b5361091b565b612d03565b509193505050565b612dfb90612e0192612dbf606090565b506020612dcb826105b3565b91612df3612dd860405190565b8094612de78583019182612a97565b90810382520384610127565b015190611992565b91901590565b6100775761007790612e1861007791610b67606090565b61108d565b604051918151808452602084019081019060208401905b828110612e7c57505081519084518201855260208282019301905b838110612e6c57505091519091011501601f01601f191660405290565b8151815260209182019101612e4f565b8151815260209182019101612e34565b9091601f906060612ea2612ba0610e4785610893565b612ead612bc9855190565b5080612ec85750505050604051600081526020810160405290565b60405193828216801560200281870181019590910101018382015b808510612ef95750508352801991011660405290565b9093602080918651815201940190612ee356fe524c505265616465723a206c656e677468206f6620636f6e74656e74206d7573a2646970667358221220450bd3030b39f31fe3c3c9d5ca0e0d46020206e442888ad8315b9f89b60490b364736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getProofValue((uint8,address,uint256,bytes32,bytes,uint256,(bytes32,bytes32,bytes32,bytes32),(bytes32,bytes)[]))": {
        "details": "This function validates the provided BedrockStateProof and returns the value of the slot or slots included in the proof.",
        "params": {
          "proof": "The BedrockStateProof struct containing the necessary proof data"
        },
        "returns": {
          "_0": "result The value of the slot or slots included in the proof"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getProofValue((uint8,address,uint256,bytes32,bytes,uint256,(bytes32,bytes32,bytes32,bytes32),(bytes32,bytes)[]))": {
        "notice": "Get the proof value for the provided BedrockStateProof"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}